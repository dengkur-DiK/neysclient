{"ast":null,"code":"import _objectWithoutProperties from \"/workspaces/neysclient/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/workspaces/neysclient/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"children\"],\n  _excluded2 = [\"path\", \"nest\", \"match\"],\n  _excluded3 = [\"to\", \"href\", \"onClick\", \"asChild\", \"children\", \"className\", \"replace\", \"state\"];\nimport { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useMemo, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst _relativePath = (base, path) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || \"/\" : \"~\" + path;\n\n/**\n * When basepath is `undefined` or '/' it is ignored (we assume it's empty string)\n */\nconst baseDefaults = function () {\n  let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return base === \"/\" ? \"\" : base;\n};\nconst absolutePath = (to, base) => to[0] === \"~\" ? to.slice(1) : baseDefaults(base) + to;\nconst relativePath = function () {\n  let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let path = arguments.length > 1 ? arguments[1] : undefined;\n  return _relativePath(unescape(baseDefaults(base)), unescape(path));\n};\n\n/*\n * Removes leading question mark\n */\nconst stripQm = str => str[0] === \"?\" ? str.slice(1) : str;\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = str => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\nconst sanitizeSearch = search => unescape(stripQm(search));\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // optional context to track render state during SSR\n  ssrContext: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: x => x\n};\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst Params0 = {},\n  ParamsCtx = createContext(Params0);\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = router => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [relativePath(router.base, location), useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts))];\n};\nconst useLocation = () => useLocationFromRouter(useRouter());\nconst useSearch = () => {\n  const router = useRouter();\n  return sanitizeSearch(router.searchHook(router));\n};\nconst matchRoute = (parser, route, path, loose) => {\n  // if the input is a regexp, skip parsing\n  const {\n    pattern,\n    keys\n  } = route instanceof RegExp ? {\n    keys: false,\n    pattern: route\n  } : parser(route || \"*\", loose);\n\n  // array destructuring loses keys, so this is done in two steps\n  const result = pattern.exec(path) || [];\n\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const [$base, ...matches] = result;\n  return $base !== undefined ? [true, (() => {\n    // for regex paths, `keys` will always be false\n\n    // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n    // we \"zip\" two arrays here to construct the object\n    // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n    const groups = keys !== false ? Object.fromEntries(keys.map((key, i) => [key, matches[i]])) : result.groups;\n\n    // convert the array to an instance of object\n    // this makes it easier to integrate with the existing param implementation\n    let obj = _objectSpread({}, matches);\n\n    // merge named capture groups with matches array\n    groups && Object.assign(obj, groups);\n    return obj;\n  })(),\n  // the third value if only present when parser is in \"loose\" mode,\n  // so that we can extract the base path for nested routes\n  ...(loose ? [$base] : [])] : [false, null];\n};\nconst useRoute = pattern => matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = _ref => {\n  var _props$ssrPath$split, _props$ssrPath, _props$hrefs, _props$hook;\n  let {\n      children\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = (_props$ssrPath$split = (_props$ssrPath = props.ssrPath) === null || _props$ssrPath === void 0 ? void 0 : _props$ssrPath.split(\"?\")) !== null && _props$ssrPath$split !== void 0 ? _props$ssrPath$split : [];\n  if (search) props.ssrSearch = search, props.ssrPath = path;\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = (_props$hrefs = props.hrefs) !== null && _props$hrefs !== void 0 ? _props$hrefs : (_props$hook = props.hook) === null || _props$hook === void 0 ? void 0 : _props$hook.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n  for (let k in parent) {\n    const option = k === \"base\" ? /* base is special case, it is appended to the parent's base */\n    parent[k] + (props[k] || \"\") : props[k] || parent[k];\n    if (prev === next && option !== next[k]) {\n      ref.current = next = _objectSpread({}, next);\n    }\n    next[k] = option;\n\n    // the new router is no different from the parent or from the memoized value, use parent\n    if (option !== parent[k] || option !== value[k]) value = next;\n  }\n  return createElement(RouterCtx.Provider, {\n    value,\n    children\n  });\n};\nconst h_route = (_ref2, params) => {\n  let {\n    children,\n    component\n  } = _ref2;\n  // React-Router style `component` prop\n  if (component) return createElement(component, {\n    params\n  });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\n// Cache params object between renders if values are shallow equal\nconst useCachedParams = value => {\n  let prev = useRef(Params0);\n  const curr = prev.current;\n  return prev.current =\n  // Update cache if number of params changed or any value changed\n  Object.keys(value).length !== Object.keys(curr).length || Object.entries(value).some(_ref3 => {\n    let [k, v] = _ref3;\n    return v !== curr[k];\n  }) ? value // Return new value if there are changes\n  : curr; // Return cached value if nothing changed\n};\nfunction useSearchParams() {\n  const [location, navigate] = useLocation();\n  const search = useSearch();\n  const searchParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  // cached value before next render, so you can call setSearchParams multiple times\n  let tempSearchParams = searchParams;\n  const setSearchParams = useEvent((nextInit, options) => {\n    tempSearchParams = new URLSearchParams(typeof nextInit === \"function\" ? nextInit(tempSearchParams) : nextInit);\n    navigate(location + \"?\" + tempSearchParams, options);\n  });\n  return [searchParams, setSearchParams];\n}\nconst Route = _ref4 => {\n  let {\n      path,\n      nest,\n      match\n    } = _ref4,\n    renderProps = _objectWithoutProperties(_ref4, _excluded2);\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n  const [matches, routeParams, base] = // `match` is a special prop to give up control to the parent,\n  // it is used by the `Switch` to avoid double matching\n  match !== null && match !== void 0 ? match : matchRoute(router.parser, path, location, nest);\n\n  // when `routeParams` is `null` (there was no match), the argument\n  // below becomes {...null} = {}, see the Object Spread specs\n  // https://tc39.es/proposal-object-rest-spread/#AbstractOperations-CopyDataProperties\n  const params = useCachedParams(_objectSpread(_objectSpread({}, useParams()), routeParams));\n  if (!matches) return null;\n  const children = base ? createElement(Router, {\n    base\n  }, h_route(renderProps, params)) : h_route(renderProps, params);\n  return createElement(ParamsCtx.Provider, {\n    value: params,\n    children\n  });\n};\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [currentPath, navigate] = useLocationFromRouter(router);\n  const {\n      to = \"\",\n      href: targetPath = to,\n      onClick: _onClick,\n      asChild,\n      children,\n      className: cls,\n      /* eslint-disable no-unused-vars */\n      replace /* ignore nav props */,\n      state /* ignore nav props */\n      /* eslint-enable no-unused-vars */\n    } = props,\n    restProps = _objectWithoutProperties(props, _excluded3);\n  const onClick = useEvent(event => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;\n    _onClick === null || _onClick === void 0 || _onClick(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(targetPath, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(targetPath[0] === \"~\" ? targetPath.slice(1) : router.base + targetPath, router // pass router as a second argument for convinience\n  );\n  return asChild && isValidElement(children) ? cloneElement(children, {\n    onClick,\n    href\n  }) : createElement(\"a\", _objectSpread(_objectSpread({}, restProps), {}, {\n    onClick,\n    href,\n    // `className` can be a function to apply the class if this link is active\n    className: cls !== null && cls !== void 0 && cls.call ? cls(currentPath === targetPath) : cls,\n    children,\n    ref\n  }));\n});\nconst flattenChildren = children => Array.isArray(children) ? children.flatMap(c => flattenChildren(c && c.type === Fragment ? c.props.children : c)) : [children];\nconst Switch = _ref5 => {\n  let {\n    children,\n    location\n  } = _ref5;\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n    if (isValidElement(element) &&\n    // we don't require an element to be of type Route,\n    // but we do require it to contain a truthy `path` prop.\n    // this allows to use different components that wrap Route\n    // inside of a switch, for example <AnimatedRoute />.\n    (match = matchRoute(router.parser, element.props.path, location || originalLocation, element.props.nest))[0]) return cloneElement(element, {\n      match\n    });\n  }\n  return null;\n};\nconst Redirect = props => {\n  const {\n    to,\n    href = to\n  } = props;\n  const router = useRouter();\n  const [, navigate] = useLocationFromRouter(router);\n  const redirect = useEvent(() => navigate(to || href, props));\n  const {\n    ssrContext\n  } = router;\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  if (ssrContext) {\n    ssrContext.redirectTo = to;\n  }\n  return null;\n};\nexport { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };","map":{"version":3,"names":["parse","useBrowserLocation","useSearch","useSearch$1","createContext","forwardRef","useEvent","isValidElement","cloneElement","createElement","useContext","useRef","useMemo","useIsomorphicLayoutEffect","Fragment","_relativePath","base","path","toLowerCase","indexOf","slice","length","baseDefaults","arguments","undefined","absolutePath","to","relativePath","unescape","stripQm","str","decodeURI","_e","sanitizeSearch","search","defaultRouter","hook","searchHook","parser","ssrPath","ssrSearch","ssrContext","hrefs","x","RouterCtx","useRouter","Params0","ParamsCtx","useParams","useLocationFromRouter","router","location","navigate","navOpts","useLocation","matchRoute","route","loose","pattern","keys","RegExp","result","exec","$base","matches","groups","Object","fromEntries","map","key","i","obj","_objectSpread","assign","useRoute","Router","_ref","_props$ssrPath$split","_props$ssrPath","_props$hrefs","_props$hook","children","props","_objectWithoutProperties","_excluded","parent_","parent","value","split","ref","prev","current","next","k","option","Provider","h_route","_ref2","params","component","useCachedParams","curr","entries","some","_ref3","v","useSearchParams","searchParams","URLSearchParams","tempSearchParams","setSearchParams","nextInit","options","Route","_ref4","nest","match","renderProps","_excluded2","routeParams","Link","currentPath","href","targetPath","onClick","_onClick","asChild","className","cls","replace","state","restProps","_excluded3","event","ctrlKey","metaKey","altKey","shiftKey","button","defaultPrevented","preventDefault","call","flattenChildren","Array","isArray","flatMap","c","type","Switch","_ref5","originalLocation","element","Redirect","redirect","redirectTo"],"sources":["/workspaces/neysclient/node_modules/wouter/esm/index.js"],"sourcesContent":["import { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useMemo, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst _relativePath = (base, path) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n\n/**\n * When basepath is `undefined` or '/' it is ignored (we assume it's empty string)\n */\nconst baseDefaults = (base = \"\") => (base === \"/\" ? \"\" : base);\n\nconst absolutePath = (to, base) =>\n  to[0] === \"~\" ? to.slice(1) : baseDefaults(base) + to;\n\nconst relativePath = (base = \"\", path) =>\n  _relativePath(unescape(baseDefaults(base)), unescape(path));\n\n/*\n * Removes leading question mark\n */\nconst stripQm = (str) => (str[0] === \"?\" ? str.slice(1) : str);\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = (str) => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\n\nconst sanitizeSearch = (search) => unescape(stripQm(search));\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // optional context to track render state during SSR\n  ssrContext: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: (x) => x,\n};\n\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst Params0 = {},\n  ParamsCtx = createContext(Params0);\n\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = (router) => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [\n    relativePath(router.base, location),\n    useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts)),\n  ];\n};\n\nconst useLocation = () => useLocationFromRouter(useRouter());\n\nconst useSearch = () => {\n  const router = useRouter();\n  return sanitizeSearch(router.searchHook(router));\n};\n\nconst matchRoute = (parser, route, path, loose) => {\n  // if the input is a regexp, skip parsing\n  const { pattern, keys } =\n    route instanceof RegExp\n      ? { keys: false, pattern: route }\n      : parser(route || \"*\", loose);\n\n  // array destructuring loses keys, so this is done in two steps\n  const result = pattern.exec(path) || [];\n\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const [$base, ...matches] = result;\n\n  return $base !== undefined\n    ? [\n        true,\n\n        (() => {\n          // for regex paths, `keys` will always be false\n\n          // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n          // we \"zip\" two arrays here to construct the object\n          // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n          const groups =\n            keys !== false\n              ? Object.fromEntries(keys.map((key, i) => [key, matches[i]]))\n              : result.groups;\n\n          // convert the array to an instance of object\n          // this makes it easier to integrate with the existing param implementation\n          let obj = { ...matches };\n\n          // merge named capture groups with matches array\n          groups && Object.assign(obj, groups);\n\n          return obj;\n        })(),\n\n        // the third value if only present when parser is in \"loose\" mode,\n        // so that we can extract the base path for nested routes\n        ...(loose ? [$base] : []),\n      ]\n    : [false, null];\n};\n\nconst useRoute = (pattern) =>\n  matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = ({ children, ...props }) => {\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = props.ssrPath?.split(\"?\") ?? [];\n  if (search) (props.ssrSearch = search), (props.ssrPath = path);\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = props.hrefs ?? props.hook?.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n\n  for (let k in parent) {\n    const option =\n      k === \"base\"\n        ? /* base is special case, it is appended to the parent's base */\n          parent[k] + (props[k] || \"\")\n        : props[k] || parent[k];\n\n    if (prev === next && option !== next[k]) {\n      ref.current = next = { ...next };\n    }\n\n    next[k] = option;\n\n    // the new router is no different from the parent or from the memoized value, use parent\n    if (option !== parent[k] || option !== value[k]) value = next;\n  }\n\n  return createElement(RouterCtx.Provider, { value, children });\n};\n\nconst h_route = ({ children, component }, params) => {\n  // React-Router style `component` prop\n  if (component) return createElement(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\n// Cache params object between renders if values are shallow equal\nconst useCachedParams = (value) => {\n  let prev = useRef(Params0);\n  const curr = prev.current;\n  return (prev.current =\n    // Update cache if number of params changed or any value changed\n    Object.keys(value).length !== Object.keys(curr).length ||\n    Object.entries(value).some(([k, v]) => v !== curr[k])\n      ? value // Return new value if there are changes\n      : curr); // Return cached value if nothing changed\n};\n\nfunction useSearchParams() {\n  const [location, navigate] = useLocation();\n\n  const search = useSearch();\n  const searchParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  // cached value before next render, so you can call setSearchParams multiple times\n  let tempSearchParams = searchParams;\n\n  const setSearchParams = useEvent((nextInit, options) => {\n    tempSearchParams = new URLSearchParams(\n      typeof nextInit === \"function\" ? nextInit(tempSearchParams) : nextInit\n    );\n    navigate(location + \"?\" + tempSearchParams, options);\n  });\n\n  return [searchParams, setSearchParams];\n}\n\nconst Route = ({ path, nest, match, ...renderProps }) => {\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n\n  const [matches, routeParams, base] =\n    // `match` is a special prop to give up control to the parent,\n    // it is used by the `Switch` to avoid double matching\n    match ?? matchRoute(router.parser, path, location, nest);\n\n  // when `routeParams` is `null` (there was no match), the argument\n  // below becomes {...null} = {}, see the Object Spread specs\n  // https://tc39.es/proposal-object-rest-spread/#AbstractOperations-CopyDataProperties\n  const params = useCachedParams({ ...useParams(), ...routeParams });\n\n  if (!matches) return null;\n\n  const children = base\n    ? createElement(Router, { base }, h_route(renderProps, params))\n    : h_route(renderProps, params);\n\n  return createElement(ParamsCtx.Provider, { value: params, children });\n};\n\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [currentPath, navigate] = useLocationFromRouter(router);\n\n  const {\n    to = \"\",\n    href: targetPath = to,\n    onClick: _onClick,\n    asChild,\n    children,\n    className: cls,\n    /* eslint-disable no-unused-vars */\n    replace /* ignore nav props */,\n    state /* ignore nav props */,\n    /* eslint-enable no-unused-vars */\n\n    ...restProps\n  } = props;\n\n  const onClick = useEvent((event) => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (\n      event.ctrlKey ||\n      event.metaKey ||\n      event.altKey ||\n      event.shiftKey ||\n      event.button !== 0\n    )\n      return;\n\n    _onClick?.(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(targetPath, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(\n    targetPath[0] === \"~\" ? targetPath.slice(1) : router.base + targetPath,\n    router // pass router as a second argument for convinience\n  );\n\n  return asChild && isValidElement(children)\n    ? cloneElement(children, { onClick, href })\n    : createElement(\"a\", {\n        ...restProps,\n        onClick,\n        href,\n        // `className` can be a function to apply the class if this link is active\n        className: cls?.call ? cls(currentPath === targetPath) : cls,\n        children,\n        ref,\n      });\n});\n\nconst flattenChildren = (children) =>\n  Array.isArray(children)\n    ? children.flatMap((c) =>\n        flattenChildren(c && c.type === Fragment ? c.props.children : c)\n      )\n    : [children];\n\nconst Switch = ({ children, location }) => {\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = matchRoute(\n        router.parser,\n        element.props.path,\n        location || originalLocation,\n        element.props.nest\n      ))[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nconst Redirect = (props) => {\n  const { to, href = to } = props;\n  const router = useRouter();\n  const [, navigate] = useLocationFromRouter(router);\n  const redirect = useEvent(() => navigate(to || href, props));\n  const { ssrContext } = router;\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  if (ssrContext) {\n    ssrContext.redirectTo = to;\n  }\n\n  return null;\n};\n\nexport { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}